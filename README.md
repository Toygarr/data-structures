### This repository includes my data structure codes written in C lang. to use concepts faster.

Because of the university restrictions I escape from using global variables so you will see the usage of address passing to change local variables in most of the codes. In other resources, they mostly prefer using global variables to make it easier to code.
_____

| Data Structures | Available Baselines | Homeworks/Projects |
| --- | --- | --- |
| Linked Lists | [Single](https://github.com/Toygarr/data-structures/blob/main/Linked%20Lists/linkedlist.c), [Circular](https://github.com/Toygarr/data-structures/blob/main/Linked%20Lists/circular_linkedlist.c), [Doubly](https://github.com/Toygarr/data-structures/blob/main/Linked%20Lists/doubly_linkedlist.c)| [Fast Search on Linked List with creating Stages](https://github.com/Toygarr/data-structures/blob/main/Linked%20Lists/HW1/fast_linkedlist.c) |
| Stacks | [Cool Stack](https://github.com/Toygarr/data-structures/blob/main/Stack/stack.c) | [Binary Bit Comparator with Stack](https://github.com/Toygarr/data-structures/blob/main/Stack/HW2/binary_stack.c)|
| Queues | [Simple](https://github.com/Toygarr/data-structures/blob/main/Queue/simple_queue.c), [Circular](https://github.com/Toygarr/data-structures/blob/main/Queue/circular_queue.c) | |
| Binary Search Trees | [BST](https://github.com/Toygarr/data-structures/blob/main/Binary%20Search%20Tree/bst.c)| [Creating BST from words in files](https://github.com/Toygarr/data-structures/tree/main/Binary%20Search%20Tree/HW3)| 
| Heap Trees and Heap Sort | [Heap Tree & Heap Sort](https://github.com/Toygarr/data-structures/blob/main/Heap%20Tree/heap.c) | |
| Graphs and Min Spanning Tree | | |
| Search Algorithms |Â | |

We can use arrays, linked lists and heap trees to implement ```priority queue``` so it has no special implementation. For example, heap tree is available to use directly as a priority queue. In max-heap trees, we are aware of the first element of tree is the biggest. We can simply use that algorithm to realize priority queue efficiently.
